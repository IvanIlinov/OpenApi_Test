"use strict";

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _default = require("../error/default");

var _OpenAPISchema = _interopRequireDefault(require("../types/OAS3/OpenAPISchema"));

var _OpenAPIDiscriminator = require("../types/OAS3/OpenAPIDiscriminator");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-case-declarations */

/* eslint-disable no-param-reassign */

/* eslint-disable class-methods-use-this */
const getComponentName = (refString, components, componentType, node, ctx) => {
  const errors = [];
  refString = refString.replace('#/', '/');

  const itemNameBase = _path.default.basename(refString, _path.default.extname(refString));

  const pathParts = _path.default.dirname(refString).split('/');

  const componentsGroup = components[componentType];
  if (!componentsGroup) return {
    name: itemNameBase,
    errors
  };
  let name = itemNameBase;
  let i = pathParts.length - 1;

  while (componentsGroup[name] && !(0, _lodash.default)(componentsGroup[name], node) && i >= 0) {
    const prevName = name;
    name = `${pathParts[i]}_${itemNameBase}`;
    errors.push(ctx.createError(`Two schemas are referenced with the same name but different content. Renamed ${prevName} to ${name}`, 'key'));
    i--;
  }

  if (i >= 0) return {
    name,
    errors
  };
  let serialId = 0;

  while (componentsGroup[name] && !(0, _lodash.default)(componentsGroup[name], node)) {
    serialId++;
    name = `${name}-${serialId}`;
  }

  return {
    name,
    errors
  };
};

class Bundler {
  constructor(config) {
    this.config = config;
    this.nameConflictsEnabled = this.config.nameConflicts !== 'off';

    if (this.nameConflictsEnabled) {
      this.nameConflictsSeverity = (0, _default.getMsgLevelFromString)(this.config.nameConflicts || '');
    }

    this.components = {};
    this.newRefNodes = new Map();
  }

  static get rule() {
    return 'bundler';
  }

  defNameToType(definitionName) {
    switch (definitionName) {
      case 'OpenAPISchema':
        return 'schemas';

      case 'OpenAPIParameter':
        return 'parameters';

      case 'OpenAPIResponse':
        return 'responses';

      case 'OpenAPIExample':
        return 'examples';

      case 'OpenAPIRequestBody':
        return 'requestBodies';

      case 'OpenAPIHeader':
        return 'headers';

      case 'OpenAPISecuritySchema':
        return 'securitySchemes';

      case 'OpenAPILink':
        return 'links';

      case 'OpenAPICallback':
        return 'callbacks';

      default:
        return null;
    }
  }

  includeImplicitDiscriminator(pointer, schemas, ctx, {
    traverseNode,
    visited
  }) {
    const $ref = `#/${pointer.join('/')}`;
    const errors = [];

    for (const [name, schema] of Object.entries(schemas || {})) {
      if (schema.allOf && schema.allOf.find(s => s.$ref === $ref)) {
        const existingSchema = this.components.schemas && this.components.schemas[name];

        if (existingSchema && !(0, _lodash.default)(existingSchema, schema)) {
          errors.push(ctx.createError(`Implicitly mapped discriminator schema "${name}" conflicts with existing schema. Skipping.`, 'key'));
        }

        this.components.schemas = this.components.schemas || {};
        this.components.schemas[name] = schema;
        ctx.pathStack.push({
          path: ctx.path,
          file: ctx.filePath,
          document: ctx.document,
          source: ctx.source
        });
        ctx.path = ['components', 'schemas', name];
        traverseNode(schema, _OpenAPISchema.default, ctx, visited);
        ctx.path = ctx.pathStack.pop().path;
      }
    }

    return errors;
  }

  any() {
    return {
      onExit: (node, definition, ctx, unresolvedNode, {
        traverseNode,
        visited
      }) => {
        let errors = [];

        if (node.discriminator && !node.oneOf && !node.anyOf && !node.mapping) {
          errors = this.includeImplicitDiscriminator(ctx.path, ctx.document.components && ctx.document.components.schemas, ctx, {
            traverseNode,
            visited
          });
        }

        if (unresolvedNode && node !== unresolvedNode && (0, _utils.isRef)(unresolvedNode)) {
          const componentType = this.defNameToType(definition.name);

          if (!componentType) {
            delete unresolvedNode.$ref;
            Object.assign(unresolvedNode, node);
          } else if (!this.newRefNodes.has(unresolvedNode)) {
            // eslint-disable-next-line prefer-const
            const {
              name,
              errors: nameErrors
            } = getComponentName(unresolvedNode.$ref, this.components, componentType, node, ctx);
            errors.push(...nameErrors);
            const newRef = `#/components/${componentType}/${name}`;

            if (!this.components[componentType]) {
              this.components[componentType] = {};
            }

            this.components[componentType][name] = node; // we can't replace nodes in-place as non-idempotent
            // nodes will be visited again and will fail bundling
            // so we save it and replace at the end

            this.newRefNodes.set(unresolvedNode, newRef);
          }
        }

        errors.forEach(e => {
          e.severity = this.nameConflictsSeverity;
        });

        if (!this.nameConflictsEnabled) {
          errors = [];
        }

        return errors;
      }
    };
  }

  OpenAPIRoot() {
    return {
      onExit: (node, definition, ctx) => {
        if (!node.components) {
          node.components = {};
        }

        if (!this.config.ignoreErrors && ctx.result.some(e => e.severity === _default.messageLevels.ERROR)) {
          ctx.bundlingResult = null;
          return null;
        }

        for (const [unresolvedNode, newRef] of this.newRefNodes.entries()) {
          if (unresolvedNode[_OpenAPIDiscriminator.MAPPING_DATA_KEY]) {
            // FIXME: too hack
            const {
              mapping,
              key
            } = unresolvedNode[_OpenAPIDiscriminator.MAPPING_DATA_KEY];
            mapping[key] = newRef;
          } else {
            unresolvedNode.$ref = newRef;
          }
        }

        Object.keys(this.components).forEach(component => {
          node.components[component] = node.components[component] ? node.components[component] : {};
          Object.assign(node.components[component], this.components[component]);
        });
        let outputFile;

        if (this.config.output) {
          outputFile = this.config.output;
          const nameParts = outputFile.split('.');
          const ext = nameParts[nameParts.length - 1];

          const outputPath = _path.default.resolve(outputFile);

          const outputDir = _path.default.dirname(outputPath);

          _fs.default.mkdirSync(outputDir, {
            recursive: true
          });

          let fileData = null;

          switch (ext) {
            case 'json':
              fileData = JSON.stringify(node, null, 2);
              break;

            case 'yaml':
            case 'yml':
            default:
              fileData = _jsYaml.default.safeDump(node);
              break;
          }

          _fs.default.writeFileSync(`${outputPath}`, fileData);
        } else if (this.config.outputObject) {
          ctx.bundlingResult = node;
        } else {
          // default output to stdout, if smbd wants to pipe it
          process.stdout.write(_jsYaml.default.safeDump(node));
          process.stdout.write('\n');
        }

        return null;
      }
    };
  }

}

module.exports = Bundler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92aXNpdG9ycy9idW5kbGVyLmpzIl0sIm5hbWVzIjpbImdldENvbXBvbmVudE5hbWUiLCJyZWZTdHJpbmciLCJjb21wb25lbnRzIiwiY29tcG9uZW50VHlwZSIsIm5vZGUiLCJjdHgiLCJlcnJvcnMiLCJyZXBsYWNlIiwiaXRlbU5hbWVCYXNlIiwicGF0aCIsImJhc2VuYW1lIiwiZXh0bmFtZSIsInBhdGhQYXJ0cyIsImRpcm5hbWUiLCJzcGxpdCIsImNvbXBvbmVudHNHcm91cCIsIm5hbWUiLCJpIiwibGVuZ3RoIiwicHJldk5hbWUiLCJwdXNoIiwiY3JlYXRlRXJyb3IiLCJzZXJpYWxJZCIsIkJ1bmRsZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsIm5hbWVDb25mbGljdHNFbmFibGVkIiwibmFtZUNvbmZsaWN0cyIsIm5hbWVDb25mbGljdHNTZXZlcml0eSIsIm5ld1JlZk5vZGVzIiwiTWFwIiwicnVsZSIsImRlZk5hbWVUb1R5cGUiLCJkZWZpbml0aW9uTmFtZSIsImluY2x1ZGVJbXBsaWNpdERpc2NyaW1pbmF0b3IiLCJwb2ludGVyIiwic2NoZW1hcyIsInRyYXZlcnNlTm9kZSIsInZpc2l0ZWQiLCIkcmVmIiwiam9pbiIsInNjaGVtYSIsIk9iamVjdCIsImVudHJpZXMiLCJhbGxPZiIsImZpbmQiLCJzIiwiZXhpc3RpbmdTY2hlbWEiLCJwYXRoU3RhY2siLCJmaWxlIiwiZmlsZVBhdGgiLCJkb2N1bWVudCIsInNvdXJjZSIsIk9wZW5BUElTY2hlbWFPYmplY3QiLCJwb3AiLCJhbnkiLCJvbkV4aXQiLCJkZWZpbml0aW9uIiwidW5yZXNvbHZlZE5vZGUiLCJkaXNjcmltaW5hdG9yIiwib25lT2YiLCJhbnlPZiIsIm1hcHBpbmciLCJhc3NpZ24iLCJoYXMiLCJuYW1lRXJyb3JzIiwibmV3UmVmIiwic2V0IiwiZm9yRWFjaCIsImUiLCJzZXZlcml0eSIsIk9wZW5BUElSb290IiwiaWdub3JlRXJyb3JzIiwicmVzdWx0Iiwic29tZSIsIm1lc3NhZ2VMZXZlbHMiLCJFUlJPUiIsImJ1bmRsaW5nUmVzdWx0IiwiTUFQUElOR19EQVRBX0tFWSIsImtleSIsImtleXMiLCJjb21wb25lbnQiLCJvdXRwdXRGaWxlIiwib3V0cHV0IiwibmFtZVBhcnRzIiwiZXh0Iiwib3V0cHV0UGF0aCIsInJlc29sdmUiLCJvdXRwdXREaXIiLCJmcyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsImZpbGVEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsInlhbWwiLCJzYWZlRHVtcCIsIndyaXRlRmlsZVN5bmMiLCJvdXRwdXRPYmplY3QiLCJwcm9jZXNzIiwic3Rkb3V0Iiwid3JpdGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBWEE7O0FBQ0E7O0FBQ0E7QUFXQSxNQUFNQSxnQkFBZ0IsR0FBRyxDQUFDQyxTQUFELEVBQVlDLFVBQVosRUFBd0JDLGFBQXhCLEVBQXVDQyxJQUF2QyxFQUE2Q0MsR0FBN0MsS0FBcUQ7QUFDNUUsUUFBTUMsTUFBTSxHQUFHLEVBQWY7QUFFQUwsRUFBQUEsU0FBUyxHQUFHQSxTQUFTLENBQUNNLE9BQVYsQ0FBa0IsSUFBbEIsRUFBd0IsR0FBeEIsQ0FBWjs7QUFDQSxRQUFNQyxZQUFZLEdBQUdDLGNBQUtDLFFBQUwsQ0FBY1QsU0FBZCxFQUF5QlEsY0FBS0UsT0FBTCxDQUFhVixTQUFiLENBQXpCLENBQXJCOztBQUNBLFFBQU1XLFNBQVMsR0FBR0gsY0FBS0ksT0FBTCxDQUFhWixTQUFiLEVBQXdCYSxLQUF4QixDQUE4QixHQUE5QixDQUFsQjs7QUFFQSxRQUFNQyxlQUFlLEdBQUdiLFVBQVUsQ0FBQ0MsYUFBRCxDQUFsQztBQUNBLE1BQUksQ0FBQ1ksZUFBTCxFQUFzQixPQUFPO0FBQUVDLElBQUFBLElBQUksRUFBRVIsWUFBUjtBQUFzQkYsSUFBQUE7QUFBdEIsR0FBUDtBQUV0QixNQUFJVSxJQUFJLEdBQUdSLFlBQVg7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QWM1RixJQUFkLENBQXJCO0FBQ0ErRixVQUFBQSxPQUFPLENBQUNDLE1BQVIsQ0FBZUMsS0FBZixDQUFxQixJQUFyQjtBQUNEOztBQUNELGVBQU8sSUFBUDtBQUNEO0FBMURJLEtBQVA7QUE0REQ7O0FBN0xXOztBQWdNZEMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCaEYsT0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoLmlzZXF1YWwnO1xuXG5pbXBvcnQgeyBnZXRNc2dMZXZlbEZyb21TdHJpbmcsIG1lc3NhZ2VMZXZlbHMgfSBmcm9tICcuLi9lcnJvci9kZWZhdWx0JztcbmltcG9ydCBPcGVuQVBJU2NoZW1hT2JqZWN0IGZyb20gJy4uL3R5cGVzL09BUzMvT3BlbkFQSVNjaGVtYSc7XG5pbXBvcnQgeyBNQVBQSU5HX0RBVEFfS0VZIH0gZnJvbSAnLi4vdHlwZXMvT0FTMy9PcGVuQVBJRGlzY3JpbWluYXRvcic7XG5pbXBvcnQgeyBpc1JlZiB9IGZyb20gJy4uL3V0aWxzJztcblxuY29uc3QgZ2V0Q29tcG9uZW50TmFtZSA9IChyZWZTdHJpbmcsIGNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUsIG5vZGUsIGN0eCkgPT4ge1xuICBjb25zdCBlcnJvcnMgPSBbXTtcblxuICByZWZTdHJpbmcgPSByZWZTdHJpbmcucmVwbGFjZSgnIy8nLCAnLycpO1xuICBjb25zdCBpdGVtTmFtZUJhc2UgPSBwYXRoLmJhc2VuYW1lKHJlZlN0cmluZywgcGF0aC5leHRuYW1lKHJlZlN0cmluZykpO1xuICBjb25zdCBwYXRoUGFydHMgPSBwYXRoLmRpcm5hbWUocmVmU3RyaW5nKS5zcGxpdCgnLycpO1xuXG4gIGNvbnN0IGNvbXBvbmVudHNHcm91cCA9IGNvbXBvbmVudHNbY29tcG9uZW50VHlwZV07XG4gIGlmICghY29tcG9uZW50c0dyb3VwKSByZXR1cm4geyBuYW1lOiBpdGVtTmFtZUJhc2UsIGVycm9ycyB9O1xuXG4gIGxldCBuYW1lID0gaXRlbU5hbWVCYXNlO1xuICBsZXQgaSA9IHBhdGhQYXJ0cy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChjb21wb25lbnRzR3JvdXBbbmFtZV0gJiYgIWlzRXF1YWwoY29tcG9uZW50c0dyb3VwW25hbWVdLCBub2RlKSAmJiBpID49IDApIHtcbiAgICBjb25zdCBwcmV2TmFtZSA9IG5hbWU7XG4gICAgbmFtZSA9IGAke3BhdGhQYXJ0c1tpXX1fJHtpdGVtTmFtZUJhc2V9YDtcblxuICAgIGVycm9ycy5wdXNoKFxuICAgICAgY3R4LmNyZWF0ZUVycm9yKFxuICAgICAgICBgVHdvIHNjaGVtYXMgYXJlIHJlZmVyZW5jZWQgd2l0aCB0aGUgc2FtZSBuYW1lIGJ1dCBkaWZmZXJlbnQgY29udGVudC4gUmVuYW1lZCAke3ByZXZOYW1lfSB0byAke25hbWV9YCxcbiAgICAgICAgJ2tleScsXG4gICAgICApLFxuICAgICk7XG4gICAgaS0tO1xuICB9XG5cbiAgaWYgKGkgPj0gMCkgcmV0dXJuIHsgbmFtZSwgZXJyb3JzIH07XG5cbiAgbGV0IHNlcmlhbElkID0gMDtcbiAgd2hpbGUgKGNvbXBvbmVudHNHcm91cFtuYW1lXSAmJiAhaXNFcXVhbChjb21wb25lbnRzR3JvdXBbbmFtZV0sIG5vZGUpKSB7XG4gICAgc2VyaWFsSWQrKztcbiAgICBuYW1lID0gYCR7bmFtZX0tJHtzZXJpYWxJZH1gO1xuICB9XG5cbiAgcmV0dXJuIHsgbmFtZSwgZXJyb3JzIH07XG59O1xuXG5jbGFzcyBCdW5kbGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5uYW1lQ29uZmxpY3RzRW5hYmxlZCA9IHRoaXMuY29uZmlnLm5hbWVDb25mbGljdHMgIT09ICdvZmYnO1xuICAgIGlmICh0aGlzLm5hbWVDb25mbGljdHNFbmFibGVkKSB7XG4gICAgICB0aGlzLm5hbWVDb25mbGljdHNTZXZlcml0eSA9IGdldE1zZ0xldmVsRnJvbVN0cmluZyh0aGlzLmNvbmZpZy5uYW1lQ29uZmxpY3RzIHx8ICcnKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb25lbnRzID0ge307XG5cbiAgICB0aGlzLm5ld1JlZk5vZGVzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBydWxlKCkge1xuICAgIHJldHVybiAnYnVuZGxlcic7XG4gIH1cblxuICBkZWZOYW1lVG9UeXBlKGRlZmluaXRpb25OYW1lKSB7XG4gICAgc3dpdGNoIChkZWZpbml0aW9uTmFtZSkge1xuICAgICAgY2FzZSAnT3BlbkFQSVNjaGVtYSc6XG4gICAgICAgIHJldHVybiAnc2NoZW1hcyc7XG4gICAgICBjYXNlICdPcGVuQVBJUGFyYW1ldGVyJzpcbiAgICAgICAgcmV0dXJuICdwYXJhbWV0ZXJzJztcbiAgICAgIGNhc2UgJ09wZW5BUElSZXNwb25zZSc6XG4gICAgICAgIHJldHVybiAncmVzcG9uc2VzJztcbiAgICAgIGNhc2UgJ09wZW5BUElFeGFtcGxlJzpcbiAgICAgICAgcmV0dXJuICdleGFtcGxlcyc7XG4gICAgICBjYXNlICdPcGVuQVBJUmVxdWVzdEJvZHknOlxuICAgICAgICByZXR1cm4gJ3JlcXVlc3RCb2RpZXMnO1xuICAgICAgY2FzZSAnT3BlbkFQSUhlYWRlcic6XG4gICAgICAgIHJldHVybiAnaGVhZGVycyc7XG4gICAgICBjYXNlICdPcGVuQVBJU2VjdXJpdHlTY2hlbWEnOlxuICAgICAgICByZXR1cm4gJ3NlY3VyaXR5U2NoZW1lcyc7XG4gICAgICBjYXNlICdPcGVuQVBJTGluayc6XG4gICAgICAgIHJldHVybiAnbGlua3MnO1xuICAgICAgY2FzZSAnT3BlbkFQSUNhbGxiYWNrJzpcbiAgICAgICAgcmV0dXJuICdjYWxsYmFja3MnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaW5jbHVkZUltcGxpY2l0RGlzY3JpbWluYXRvcihwb2ludGVyLCBzY2hlbWFzLCBjdHgsIHsgdHJhdmVyc2VOb2RlLCB2aXNpdGVkIH0pIHtcbiAgICBjb25zdCAkcmVmID0gYCMvJHtwb2ludGVyLmpvaW4oJy8nKX1gO1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgc2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhzY2hlbWFzIHx8IHt9KSkge1xuICAgICAgaWYgKHNjaGVtYS5hbGxPZiAmJiBzY2hlbWEuYWxsT2YuZmluZCgocykgPT4gcy4kcmVmID09PSAkcmVmKSkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1NjaGVtYSA9IHRoaXMuY29tcG9uZW50cy5zY2hlbWFzICYmIHRoaXMuY29tcG9uZW50cy5zY2hlbWFzW25hbWVdO1xuICAgICAgICBpZiAoZXhpc3RpbmdTY2hlbWEgJiYgIWlzRXF1YWwoZXhpc3RpbmdTY2hlbWEsIHNjaGVtYSkpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChjdHguY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBgSW1wbGljaXRseSBtYXBwZWQgZGlzY3JpbWluYXRvciBzY2hlbWEgXCIke25hbWV9XCIgY29uZmxpY3RzIHdpdGggZXhpc3Rpbmcgc2NoZW1hLiBTa2lwcGluZy5gLCAna2V5JyxcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5zY2hlbWFzID0gdGhpcy5jb21wb25lbnRzLnNjaGVtYXMgfHwge307XG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5zY2hlbWFzW25hbWVdID0gc2NoZW1hO1xuXG4gICAgICAgIGN0eC5wYXRoU3RhY2sucHVzaCh7XG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgZmlsZTogY3R4LmZpbGVQYXRoLFxuICAgICAgICAgIGRvY3VtZW50OiBjdHguZG9jdW1lbnQsXG4gICAgICAgICAgc291cmNlOiBjdHguc291cmNlLFxuICAgICAgICB9KTtcblxuICAgICAgICBjdHgucGF0aCA9IFsnY29tcG9uZW50cycsICdzY2hlbWFzJywgbmFtZV07XG4gICAgICAgIHRyYXZlcnNlTm9kZShzY2hlbWEsIE9wZW5BUElTY2hlbWFPYmplY3QsIGN0eCwgdmlzaXRlZCk7XG4gICAgICAgIGN0eC5wYXRoID0gY3R4LnBhdGhTdGFjay5wb3AoKS5wYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICBhbnkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXhpdDogKG5vZGUsIGRlZmluaXRpb24sIGN0eCwgdW5yZXNvbHZlZE5vZGUsIHsgdHJhdmVyc2VOb2RlLCB2aXNpdGVkIH0pID0+IHtcbiAgICAgICAgbGV0IGVycm9ycyA9IFtdO1xuXG4gICAgICAgIGlmIChub2RlLmRpc2NyaW1pbmF0b3IgJiYgIW5vZGUub25lT2YgJiYgIW5vZGUuYW55T2YgJiYgIW5vZGUubWFwcGluZykge1xuICAgICAgICAgIGVycm9ycyA9IHRoaXMuaW5jbHVkZUltcGxpY2l0RGlzY3JpbWluYXRvcihcbiAgICAgICAgICAgIGN0eC5wYXRoLFxuICAgICAgICAgICAgY3R4LmRvY3VtZW50LmNvbXBvbmVudHMgJiYgY3R4LmRvY3VtZW50LmNvbXBvbmVudHMuc2NoZW1hcyxcbiAgICAgICAgICAgIGN0eCxcbiAgICAgICAgICAgIHsgdHJhdmVyc2VOb2RlLCB2aXNpdGVkIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bnJlc29sdmVkTm9kZSAmJiBub2RlICE9PSB1bnJlc29sdmVkTm9kZSAmJiBpc1JlZih1bnJlc29sdmVkTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBjb21wb25lbnRUeXBlID0gdGhpcy5kZWZOYW1lVG9UeXBlKGRlZmluaXRpb24ubmFtZSk7XG5cbiAgICAgICAgICBpZiAoIWNvbXBvbmVudFR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB1bnJlc29sdmVkTm9kZS4kcmVmO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih1bnJlc29sdmVkTm9kZSwgbm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5uZXdSZWZOb2Rlcy5oYXModW5yZXNvbHZlZE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGVycm9yczogbmFtZUVycm9ycyB9ID0gZ2V0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICAgICAgdW5yZXNvbHZlZE5vZGUuJHJlZiwgdGhpcy5jb21wb25lbnRzLCBjb21wb25lbnRUeXBlLCBub2RlLCBjdHgsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBlcnJvcnMucHVzaCguLi5uYW1lRXJyb3JzKTtcblxuICAgICAgICAgICAgY29uc3QgbmV3UmVmID0gYCMvY29tcG9uZW50cy8ke2NvbXBvbmVudFR5cGV9LyR7bmFtZX1gO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29tcG9uZW50c1tjb21wb25lbnRUeXBlXSkge1xuICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50VHlwZV0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudFR5cGVdW25hbWVdID0gbm9kZTtcbiAgICAgICAgICAgIC8vIHdlIGNhbid0IHJlcGxhY2Ugbm9kZXMgaW4tcGxhY2UgYXMgbm9uLWlkZW1wb3RlbnRcbiAgICAgICAgICAgIC8vIG5vZGVzIHdpbGwgYmUgdmlzaXRlZCBhZ2FpbiBhbmQgd2lsbCBmYWlsIGJ1bmRsaW5nXG4gICAgICAgICAgICAvLyBzbyB3ZSBzYXZlIGl0IGFuZCByZXBsYWNlIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIHRoaXMubmV3UmVmTm9kZXMuc2V0KHVucmVzb2x2ZWROb2RlLCBuZXdSZWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9ycy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgZS5zZXZlcml0eSA9IHRoaXMubmFtZUNvbmZsaWN0c1NldmVyaXR5O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXRoaXMubmFtZUNvbmZsaWN0c0VuYWJsZWQpIHtcbiAgICAgICAgICBlcnJvcnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBPcGVuQVBJUm9vdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FeGl0OiAobm9kZSwgZGVmaW5pdGlvbiwgY3R4KSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5jb21wb25lbnRzKSB7XG4gICAgICAgICAgbm9kZS5jb21wb25lbnRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmlnbm9yZUVycm9ycyAmJiBjdHgucmVzdWx0LnNvbWUoKGUpID0+IGUuc2V2ZXJpdHkgPT09IG1lc3NhZ2VMZXZlbHMuRVJST1IpKSB7XG4gICAgICAgICAgY3R4LmJ1bmRsaW5nUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgW3VucmVzb2x2ZWROb2RlLCBuZXdSZWZdIG9mIHRoaXMubmV3UmVmTm9kZXMuZW50cmllcygpKSB7XG4gICAgICAgICAgaWYgKHVucmVzb2x2ZWROb2RlW01BUFBJTkdfREFUQV9LRVldKSB7IC8vIEZJWE1FOiB0b28gaGFja1xuICAgICAgICAgICAgY29uc3QgeyBtYXBwaW5nLCBrZXkgfSA9IHVucmVzb2x2ZWROb2RlW01BUFBJTkdfREFUQV9LRVldO1xuICAgICAgICAgICAgbWFwcGluZ1trZXldID0gbmV3UmVmO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bnJlc29sdmVkTm9kZS4kcmVmID0gbmV3UmVmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50cykuZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgbm9kZS5jb21wb25lbnRzW2NvbXBvbmVudF0gPSBub2RlLmNvbXBvbmVudHNbY29tcG9uZW50XSA/IG5vZGUuY29tcG9uZW50c1tjb21wb25lbnRdIDoge307XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLmNvbXBvbmVudHNbY29tcG9uZW50XSwgdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBsZXQgb3V0cHV0RmlsZTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcub3V0cHV0KSB7XG4gICAgICAgICAgb3V0cHV0RmlsZSA9IHRoaXMuY29uZmlnLm91dHB1dDtcbiAgICAgICAgICBjb25zdCBuYW1lUGFydHMgPSBvdXRwdXRGaWxlLnNwbGl0KCcuJyk7XG4gICAgICAgICAgY29uc3QgZXh0ID0gbmFtZVBhcnRzW25hbWVQYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGNvbnN0IG91dHB1dFBhdGggPSBwYXRoLnJlc29sdmUob3V0cHV0RmlsZSk7XG5cbiAgICAgICAgICBjb25zdCBvdXRwdXREaXIgPSBwYXRoLmRpcm5hbWUob3V0cHV0UGF0aCk7XG4gICAgICAgICAgZnMubWtkaXJTeW5jKG91dHB1dERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgICAgICAgICBsZXQgZmlsZURhdGEgPSBudWxsO1xuXG4gICAgICAgICAgc3dpdGNoIChleHQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICBmaWxlRGF0YSA9IEpTT04uc3RyaW5naWZ5KG5vZGUsIG51bGwsIDIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3lhbWwnOlxuICAgICAgICAgICAgY2FzZSAneW1sJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGZpbGVEYXRhID0geWFtbC5zYWZlRHVtcChub2RlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoYCR7b3V0cHV0UGF0aH1gLCBmaWxlRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcub3V0cHV0T2JqZWN0KSB7XG4gICAgICAgICAgY3R4LmJ1bmRsaW5nUmVzdWx0ID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IG91dHB1dCB0byBzdGRvdXQsIGlmIHNtYmQgd2FudHMgdG8gcGlwZSBpdFxuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHlhbWwuc2FmZUR1bXAobm9kZSkpO1xuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1bmRsZXI7XG4iXX0=