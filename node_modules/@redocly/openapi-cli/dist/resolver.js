"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popPath = popPath;
exports.resolveNodeNoSideEffects = resolveNodeNoSideEffects;
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _path = require("path");

var _url = require("url");

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _error = _interopRequireWildcard(require("./error"));

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pushPath(ctx, filePath, docPath) {
  ctx.pathStack.push({
    path: ctx.path,
    file: ctx.filePath,
    document: ctx.document,
    source: ctx.source
  });
  ctx.path = docPath;
  ctx.filePath = filePath;
}

function decodePointerComponent(component) {
  return component.replace(/~1/, '/').replace(/~0/g, '~');
}

function popPath(ctx) {
  const topPath = ctx.pathStack.pop();
  ctx.path = topPath.path;
  ctx.filePath = topPath.file;
  ctx.source = topPath.source;
  ctx.document = topPath.document;
}
/**
 *
 * Here we go over each of the steps in the link and try to retreive the value
 * for it. If failed (e.g. because of undefined value) -- return null, to indicate that such
 * reference does not exist.
 *
 * TODO: we might need a feature to support validation of "URL" based definitions in the future, so
 * would be nice to have opportunity to call resolve() with empty ctx.
 *
 * TODO: add per-file/per-url cache
 *
 * @param {string} link A path in the yaml document which is to be resolved
 * @param {*} ctx JSON Object with the document field which represents the YAML structure
 */


async function resolve(link, ctx, visited = []) {
  const linkSplitted = link.split('#/');
  if (linkSplitted[0] === '') linkSplitted[0] = ctx.filePath;
  const [filePath, docPath] = linkSplitted;
  const resolvedFilePath = (0, _utils.isFullyQualifiedUrl)(ctx.filePath) || (0, _utils.isFullyQualifiedUrl)(filePath) ? (0, _url.resolve)(ctx.filePath, filePath) : (0, _path.resolve)((0, _path.dirname)(ctx.filePath), filePath);
  let document;
  let source;
  const isCurrentDocument = resolvedFilePath === ctx.filePath;
  pushPath(ctx, resolvedFilePath, []);
  const resolvedLink = `${resolvedFilePath}#/${docPath}`;

  if (!isCurrentDocument) {
    if (ctx.resolveCache[resolvedFilePath]) {
      ({
        source,
        document
      } = ctx.resolveCache[resolvedFilePath]);
    } else if (_fs.default.existsSync(resolvedFilePath)) {
      ctx.fileDependencies.add(resolvedFilePath); // FIXME: if refernced e.g. md file, no need to parse

      source = _fs.default.readFileSync(resolvedFilePath, 'utf-8');

      try {
        document = _jsYaml.default.safeLoad(source);
      } catch (e) {
        ctx.result.push((0, _error.createYAMLParseError)(e, ctx, resolvedFilePath));
        return {
          node: undefined
        };
      }
    } else if ((0, _utils.isFullyQualifiedUrl)(resolvedFilePath)) {
      try {
        const headers = {};

        for (let i = 0; i < ctx.headers.length; i++) {
          if ((0, _utils.match)(resolvedFilePath, ctx.headers[i].matches)) {
            headers[ctx.headers[i].name] = ctx.headers[i].value;
          }
        }

        const req = await (0, _nodeFetch.default)(resolvedFilePath, {
          headers
        });

        if (!req.ok) {
          return {
            node: undefined
          };
        }

        const text = await req.text();

        try {
          source = text;
          document = _jsYaml.default.safeLoad(text);
        } catch (e) {
          ctx.result.push((0, _error.createYAMLParseError)(e, ctx, resolvedFilePath));
          return {
            node: undefined
          };
        }
      } catch (e) {
        // FIXME: lost yaml parsing errors and network errors here
        return {
          node: undefined
        };
      }
    } else {
      return {
        node: undefined
      };
    }
  } else {
    document = ctx.document;
    source = ctx.source;
  }

  if (source) ctx.resolveCache[resolvedFilePath] = {
    source,
    document
  };
  ctx.source = source;
  ctx.document = document;
  const docPathSteps = docPath ? docPath.split('/').filter(el => el !== '').reverse() : [];
  let target = document;
  let circular;
  let transitiveResolvesOnStack = 0;
  let transitiveError;

  if (visited.indexOf(resolvedLink) > -1) {
    target = undefined;
    circular = true;
  }

  visited.push(resolvedLink);

  while (target !== undefined) {
    if (target && target.$ref) {
      // handle transitive $ref's
      const resolved = await resolve(target.$ref, ctx, visited);
      transitiveError = resolved.transitiveError;

      if (resolved.node === undefined && !transitiveError) {
        // We want to show only the error for the first $ref that can't be resolved.
        // So we create it on the current stack and propagate it out as a transitiveError
        popPath(ctx);
        ctx.path.push('$ref');
        const message = resolved.circular ? 'Circular reference.' : 'Reference does not exist.';
        transitiveError = (0, _error.default)(message, target, ctx, {
          fromRule: 'resolve-ref'
        });
        ctx.path.pop();
        target = undefined;
        break;
      }

      target = resolved.node;
      transitiveResolvesOnStack++;
    }

    let step = docPathSteps.pop();
    if (!step) break;
    step = decodePointerComponent(step);
    target = target && target[step] !== undefined ? target[step] : undefined;
    ctx.path.push(step);
  }

  for (let i = 0; i < transitiveResolvesOnStack; ++i) {
    // keep current file context and remove indirection records
    ctx.pathStack.pop();
  }

  if (transitiveError) {
    // recalc referencedFrom after exiting transitive ref stack to show original $ref in the error
    transitiveError.referencedFrom = (0, _error.getReferencedFrom)(ctx);
  }

  return {
    node: target,
    transitiveError,
    circular
  };
}
/*
 * This function is used to resolve $ref fields inside the node. Currently supports links:
 * - inside the file
 * - to the another file in local file system
 * - http(s) links to other files
 *
 * $ref field value must be a valid OpenAPI link
 * (e.g. another/dir/file.yaml#/components/schemas/Example)
 *
 * @param {*} node
 * @param {*} ctx
 */


async function resolveNode(node, ctx) {
  if (!node || typeof node !== 'object') return {
    node
  };

  if (node.$ref) {
    const resolved = await resolve(node.$ref, ctx);

    if (resolved.node === undefined) {
      // can't resolve
      popPath(ctx);
      ctx.path.push('$ref');
      const error = resolved.transitiveError ? resolved.transitiveError : (0, _error.default)('Reference does not exist.', node, ctx, {
        fromRule: 'resolve-ref'
      });
      ctx.path.pop();
      ctx.result.push(error);
      return {
        node
      };
    }

    return {
      node: resolved.node,
      onStack: true
    };
  }

  return {
    node
  };
} // to be used in mutators


async function resolveNodeNoSideEffects(node, ctx) {
  const ctxCopy = { ...ctx,
    pathStack: ctx.pathStack.slice()
  };
  return resolveNode(node, ctxCopy);
}

var _default = resolveNode;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXNvbHZlci5qcyJdLCJuYW1lcyI6WyJwdXNoUGF0aCIsImN0eCIsImZpbGVQYXRoIiwiZG9jUGF0aCIsInBhdGhTdGFjayIsInB1c2giLCJwYXRoIiwiZmlsZSIsImRvY3VtZW50Iiwic291cmNlIiwiZGVjb2RlUG9pbnRlckNvbXBvbmVudCIsImNvbXBvbmVudCIsInJlcGxhY2UiLCJwb3BQYXRoIiwidG9wUGF0aCIsInBvcCIsInJlc29sdmUiLCJsaW5rIiwidmlzaXRlZCIsImxpbmtTcGxpdHRlZCIsInNwbGl0IiwicmVzb2x2ZWRGaWxlUGF0aCIsImlzQ3VycmVudERvY3VtZW50IiwicmVzb2x2ZWRMaW5rIiwicmVzb2x2ZUNhY2hlIiwiZnMiLCJleGlzdHNTeW5jIiwiZmlsZURlcGVuZGVuY2llcyIsImFkZCIsInJlYWRGaWxlU3luYyIsInlhbWwiLCJzYWZlTG9hZCIsImUiLCJyZXN1bHQiLCJub2RlIiwidW5kZWZpbmVkIiwiaGVhZGVycyIsImkiLCJsZW5ndGgiLCJtYXRjaGVzIiwibmFtZSIsInZhbHVlIiwicmVxIiwib2siLCJ0ZXh0IiwiZG9jUGF0aFN0ZXBzIiwiZmlsdGVyIiwiZWwiLCJyZXZlcnNlIiwidGFyZ2V0IiwiY2lyY3VsYXIiLCJ0cmFuc2l0aXZlUmVzb2x2ZXNPblN0YWNrIiwidHJhbnNpdGl2ZUVycm9yIiwiaW5kZXhPZiIsIiRyZWYiLCJyZXNvbHZlZCIsIm1lc3NhZ2UiLCJmcm9tUnVsZSIsInN0ZXAiLCJyZWZlcmVuY2VkRnJvbSIsInJlc29sdmVOb2RlIiwiZXJyb3IiLCJvblN0YWNrIiwicmVzb2x2ZU5vZGVOb1NpZGVFZmZlY3RzIiwiY3R4Q29weSIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7QUFFQSxTQUFTQSxRQUFULENBQWtCQyxHQUFsQixFQUF1QkMsUUFBdkIsRUFBaUNDLE9BQWpDLEVBQTBDO0FB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QVNELElBQVQsQ0FBYyxNQUFkO0FBQ0EsWUFBTXdELEtBQUssR0FBR04sUUFBUSxDQUFDSCxlQUFULEdBQ1ZHLFFBQVEsQ0FBQ0gsZUFEQyxHQUVWLG9CQUFZLDJCQUFaLEVBQXlDbEIsSUFBekMsRUFBK0NqQyxHQUEvQyxFQUFvRDtBQUFFd0QsUUFBQUEsUUFBUSxFQUFFO0FBQVosT0FBcEQsQ0FGSjtBQUdBeEQsTUFBQUEsR0FBRyxDQUFDSyxJQUFKLENBQVNTLEdBQVQ7QUFFQWQsTUFBQUEsR0FBRyxDQUFDZ0MsTUFBSixDQUFXNUIsSUFBWCxDQUFnQndELEtBQWhCO0FBRUEsYUFBTztBQUFFM0IsUUFBQUE7QUFBRixPQUFQO0FBQ0Q7O0FBRUQsV0FBTztBQUFFQSxNQUFBQSxJQUFJLEVBQUVxQixRQUFRLENBQUNyQixJQUFqQjtBQUF1QjRCLE1BQUFBLE9BQU8sRUFBRTtBQUFoQyxLQUFQO0FBQ0Q7O0FBRUQsU0FBTztBQUFFNUIsSUFBQUE7QUFBRixHQUFQO0FBQ0QsQyxDQUVEOzs7QUFDTyxlQUFlNkIsd0JBQWYsQ0FBd0M3QixJQUF4QyxFQUE4Q2pDLEdBQTlDLEVBQW1EO0FBQ3hELFFBQU0rRCxPQUFPLEdBQUcsRUFBRSxHQUFHL0QsR0FBTDtBQUFVRyxJQUFBQSxTQUFTLEVBQUVILEdBQUcsQ0FBQ0csU0FBSixDQUFjNkQsS0FBZDtBQUFyQixHQUFoQjtBQUNBLFNBQU9MLFdBQVcsQ0FBQzFCLElBQUQsRUFBTzhCLE9BQVAsQ0FBbEI7QUFDRDs7ZUFFY0osVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5cbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyByZXNvbHZlRmlsZSwgZGlybmFtZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyByZXNvbHZlVXJsIH0gZnJvbSAndXJsJztcbmltcG9ydCBmZXRjaCBmcm9tICdub2RlLWZldGNoJztcblxuaW1wb3J0IGNyZWF0ZUVycm9yLCB7IGdldFJlZmVyZW5jZWRGcm9tLCBjcmVhdGVZQU1MUGFyc2VFcnJvciB9IGZyb20gJy4vZXJyb3InO1xuaW1wb3J0IHsgaXNGdWxseVF1YWxpZmllZFVybCwgbWF0Y2ggfSBmcm9tICcuL3V0aWxzJztcblxuZnVuY3Rpb24gcHVzaFBhdGgoY3R4LCBmaWxlUGF0aCwgZG9jUGF0aCkge1xuICBjdHgucGF0aFN0YWNrLnB1c2goe1xuICAgIHBhdGg6IGN0eC5wYXRoLCBmaWxlOiBjdHguZmlsZVBhdGgsIGRvY3VtZW50OiBjdHguZG9jdW1lbnQsIHNvdXJjZTogY3R4LnNvdXJjZSxcbiAgfSk7XG5cbiAgY3R4LnBhdGggPSBkb2NQYXRoO1xuICBjdHguZmlsZVBhdGggPSBmaWxlUGF0aDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUG9pbnRlckNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGNvbXBvbmVudC5yZXBsYWNlKC9+MS8sICcvJykucmVwbGFjZSgvfjAvZywgJ34nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcFBhdGgoY3R4KSB7XG4gIGNvbnN0IHRvcFBhdGggPSBjdHgucGF0aFN0YWNrLnBvcCgpO1xuICBjdHgucGF0aCA9IHRvcFBhdGgucGF0aDtcbiAgY3R4LmZpbGVQYXRoID0gdG9wUGF0aC5maWxlO1xuICBjdHguc291cmNlID0gdG9wUGF0aC5zb3VyY2U7XG4gIGN0eC5kb2N1bWVudCA9IHRvcFBhdGguZG9jdW1lbnQ7XG59XG5cbi8qKlxuICpcbiAqIEhlcmUgd2UgZ28gb3ZlciBlYWNoIG9mIHRoZSBzdGVwcyBpbiB0aGUgbGluayBhbmQgdHJ5IHRvIHJldHJlaXZlIHRoZSB2YWx1ZVxuICogZm9yIGl0LiBJZiBmYWlsZWQgKGUuZy4gYmVjYXVzZSBvZiB1bmRlZmluZWQgdmFsdWUpIC0tIHJldHVybiBudWxsLCB0byBpbmRpY2F0ZSB0aGF0IHN1Y2hcbiAqIHJlZmVyZW5jZSBkb2VzIG5vdCBleGlzdC5cbiAqXG4gKiBUT0RPOiB3ZSBtaWdodCBuZWVkIGEgZmVhdHVyZSB0byBzdXBwb3J0IHZhbGlkYXRpb24gb2YgXCJVUkxcIiBiYXNlZCBkZWZpbml0aW9ucyBpbiB0aGUgZnV0dXJlLCBzb1xuICogd291bGQgYmUgbmljZSB0byBoYXZlIG9wcG9ydHVuaXR5IHRvIGNhbGwgcmVzb2x2ZSgpIHdpdGggZW1wdHkgY3R4LlxuICpcbiAqIFRPRE86IGFkZCBwZXItZmlsZS9wZXItdXJsIGNhY2hlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmsgQSBwYXRoIGluIHRoZSB5YW1sIGRvY3VtZW50IHdoaWNoIGlzIHRvIGJlIHJlc29sdmVkXG4gKiBAcGFyYW0geyp9IGN0eCBKU09OIE9iamVjdCB3aXRoIHRoZSBkb2N1bWVudCBmaWVsZCB3aGljaCByZXByZXNlbnRzIHRoZSBZQU1MIHN0cnVjdHVyZVxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlKGxpbmssIGN0eCwgdmlzaXRlZCA9IFtdKSB7XG4gIGNvbnN0IGxpbmtTcGxpdHRlZCA9IGxpbmsuc3BsaXQoJyMvJyk7XG4gIGlmIChsaW5rU3BsaXR0ZWRbMF0gPT09ICcnKSBsaW5rU3BsaXR0ZWRbMF0gPSBjdHguZmlsZVBhdGg7XG4gIGNvbnN0IFtmaWxlUGF0aCwgZG9jUGF0aF0gPSBsaW5rU3BsaXR0ZWQ7XG5cbiAgY29uc3QgcmVzb2x2ZWRGaWxlUGF0aCA9IChpc0Z1bGx5UXVhbGlmaWVkVXJsKGN0eC5maWxlUGF0aCkgfHwgaXNGdWxseVF1YWxpZmllZFVybChmaWxlUGF0aCkpXG4gICAgPyByZXNvbHZlVXJsKGN0eC5maWxlUGF0aCwgZmlsZVBhdGgpXG4gICAgOiByZXNvbHZlRmlsZShkaXJuYW1lKGN0eC5maWxlUGF0aCksIGZpbGVQYXRoKTtcblxuICBsZXQgZG9jdW1lbnQ7XG4gIGxldCBzb3VyY2U7XG5cbiAgY29uc3QgaXNDdXJyZW50RG9jdW1lbnQgPSByZXNvbHZlZEZpbGVQYXRoID09PSBjdHguZmlsZVBhdGg7XG5cbiAgcHVzaFBhdGgoY3R4LCByZXNvbHZlZEZpbGVQYXRoLCBbXSk7XG5cbiAgY29uc3QgcmVzb2x2ZWRMaW5rID0gYCR7cmVzb2x2ZWRGaWxlUGF0aH0jLyR7ZG9jUGF0aH1gO1xuXG4gIGlmICghaXNDdXJyZW50RG9jdW1lbnQpIHtcbiAgICBpZiAoY3R4LnJlc29sdmVDYWNoZVtyZXNvbHZlZEZpbGVQYXRoXSkge1xuICAgICAgKHsgc291cmNlLCBkb2N1bWVudCB9ID0gY3R4LnJlc29sdmVDYWNoZVtyZXNvbHZlZEZpbGVQYXRoXSk7XG4gICAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKHJlc29sdmVkRmlsZVBhdGgpKSB7XG4gICAgICBjdHguZmlsZURlcGVuZGVuY2llcy5hZGQocmVzb2x2ZWRGaWxlUGF0aCk7XG4gICAgICAvLyBGSVhNRTogaWYgcmVmZXJuY2VkIGUuZy4gbWQgZmlsZSwgbm8gbmVlZCB0byBwYXJzZVxuICAgICAgc291cmNlID0gZnMucmVhZEZpbGVTeW5jKHJlc29sdmVkRmlsZVBhdGgsICd1dGYtOCcpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jdW1lbnQgPSB5YW1sLnNhZmVMb2FkKHNvdXJjZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGN0eC5yZXN1bHQucHVzaChjcmVhdGVZQU1MUGFyc2VFcnJvcihlLCBjdHgsIHJlc29sdmVkRmlsZVBhdGgpKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Z1bGx5UXVhbGlmaWVkVXJsKHJlc29sdmVkRmlsZVBhdGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3R4LmhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobWF0Y2gocmVzb2x2ZWRGaWxlUGF0aCwgY3R4LmhlYWRlcnNbaV0ubWF0Y2hlcykpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbY3R4LmhlYWRlcnNbaV0ubmFtZV0gPSBjdHguaGVhZGVyc1tpXS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXEgPSBhd2FpdCBmZXRjaChyZXNvbHZlZEZpbGVQYXRoLCB7IGhlYWRlcnMgfSk7XG5cbiAgICAgICAgaWYgKCFyZXEub2spIHtcbiAgICAgICAgICByZXR1cm4geyBub2RlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXEudGV4dCgpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc291cmNlID0gdGV4dDtcbiAgICAgICAgICBkb2N1bWVudCA9IHlhbWwuc2FmZUxvYWQodGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjdHgucmVzdWx0LnB1c2goY3JlYXRlWUFNTFBhcnNlRXJyb3IoZSwgY3R4LCByZXNvbHZlZEZpbGVQYXRoKSk7XG4gICAgICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRklYTUU6IGxvc3QgeWFtbCBwYXJzaW5nIGVycm9ycyBhbmQgbmV0d29yayBlcnJvcnMgaGVyZVxuICAgICAgICByZXR1cm4geyBub2RlOiB1bmRlZmluZWQgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50ID0gY3R4LmRvY3VtZW50O1xuICAgIHNvdXJjZSA9IGN0eC5zb3VyY2U7XG4gIH1cblxuICBpZiAoc291cmNlKSBjdHgucmVzb2x2ZUNhY2hlW3Jlc29sdmVkRmlsZVBhdGhdID0geyBzb3VyY2UsIGRvY3VtZW50IH07XG5cbiAgY3R4LnNvdXJjZSA9IHNvdXJjZTtcbiAgY3R4LmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgY29uc3QgZG9jUGF0aFN0ZXBzID0gZG9jUGF0aCA/IGRvY1BhdGguc3BsaXQoJy8nKS5maWx0ZXIoKGVsKSA9PiBlbCAhPT0gJycpLnJldmVyc2UoKSA6IFtdO1xuXG4gIGxldCB0YXJnZXQgPSBkb2N1bWVudDtcbiAgbGV0IGNpcmN1bGFyO1xuICBsZXQgdHJhbnNpdGl2ZVJlc29sdmVzT25TdGFjayA9IDA7XG4gIGxldCB0cmFuc2l0aXZlRXJyb3I7XG5cbiAgaWYgKHZpc2l0ZWQuaW5kZXhPZihyZXNvbHZlZExpbmspID4gLTEpIHtcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuICB9XG5cbiAgdmlzaXRlZC5wdXNoKHJlc29sdmVkTGluayk7XG5cbiAgd2hpbGUgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuJHJlZikge1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpdmUgJHJlZidzXG4gICAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHJlc29sdmUodGFyZ2V0LiRyZWYsIGN0eCwgdmlzaXRlZCk7XG4gICAgICB0cmFuc2l0aXZlRXJyb3IgPSByZXNvbHZlZC50cmFuc2l0aXZlRXJyb3I7XG4gICAgICBpZiAocmVzb2x2ZWQubm9kZSA9PT0gdW5kZWZpbmVkICYmICF0cmFuc2l0aXZlRXJyb3IpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBzaG93IG9ubHkgdGhlIGVycm9yIGZvciB0aGUgZmlyc3QgJHJlZiB0aGF0IGNhbid0IGJlIHJlc29sdmVkLlxuICAgICAgICAvLyBTbyB3ZSBjcmVhdGUgaXQgb24gdGhlIGN1cnJlbnQgc3RhY2sgYW5kIHByb3BhZ2F0ZSBpdCBvdXQgYXMgYSB0cmFuc2l0aXZlRXJyb3JcbiAgICAgICAgcG9wUGF0aChjdHgpO1xuICAgICAgICBjdHgucGF0aC5wdXNoKCckcmVmJyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXNvbHZlZC5jaXJjdWxhciA/ICdDaXJjdWxhciByZWZlcmVuY2UuJyA6ICdSZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuJztcbiAgICAgICAgdHJhbnNpdGl2ZUVycm9yID0gY3JlYXRlRXJyb3IobWVzc2FnZSwgdGFyZ2V0LCBjdHgsIHsgZnJvbVJ1bGU6ICdyZXNvbHZlLXJlZicgfSk7XG4gICAgICAgIGN0eC5wYXRoLnBvcCgpO1xuICAgICAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0ID0gcmVzb2x2ZWQubm9kZTtcbiAgICAgIHRyYW5zaXRpdmVSZXNvbHZlc09uU3RhY2srKztcbiAgICB9XG5cbiAgICBsZXQgc3RlcCA9IGRvY1BhdGhTdGVwcy5wb3AoKTtcbiAgICBpZiAoIXN0ZXApIGJyZWFrO1xuICAgIHN0ZXAgPSBkZWNvZGVQb2ludGVyQ29tcG9uZW50KHN0ZXApO1xuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0ICYmIHRhcmdldFtzdGVwXSAhPT0gdW5kZWZpbmVkID8gdGFyZ2V0W3N0ZXBdIDogdW5kZWZpbmVkO1xuICAgIGN0eC5wYXRoLnB1c2goc3RlcCk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zaXRpdmVSZXNvbHZlc09uU3RhY2s7ICsraSkge1xuICAgIC8vIGtlZXAgY3VycmVudCBmaWxlIGNvbnRleHQgYW5kIHJlbW92ZSBpbmRpcmVjdGlvbiByZWNvcmRzXG4gICAgY3R4LnBhdGhTdGFjay5wb3AoKTtcbiAgfVxuXG4gIGlmICh0cmFuc2l0aXZlRXJyb3IpIHtcbiAgICAvLyByZWNhbGMgcmVmZXJlbmNlZEZyb20gYWZ0ZXIgZXhpdGluZyB0cmFuc2l0aXZlIHJlZiBzdGFjayB0byBzaG93IG9yaWdpbmFsICRyZWYgaW4gdGhlIGVycm9yXG4gICAgdHJhbnNpdGl2ZUVycm9yLnJlZmVyZW5jZWRGcm9tID0gZ2V0UmVmZXJlbmNlZEZyb20oY3R4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbm9kZTogdGFyZ2V0LFxuICAgIHRyYW5zaXRpdmVFcnJvcixcbiAgICBjaXJjdWxhcixcbiAgfTtcbn1cblxuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlc29sdmUgJHJlZiBmaWVsZHMgaW5zaWRlIHRoZSBub2RlLiBDdXJyZW50bHkgc3VwcG9ydHMgbGlua3M6XG4gKiAtIGluc2lkZSB0aGUgZmlsZVxuICogLSB0byB0aGUgYW5vdGhlciBmaWxlIGluIGxvY2FsIGZpbGUgc3lzdGVtXG4gKiAtIGh0dHAocykgbGlua3MgdG8gb3RoZXIgZmlsZXNcbiAqXG4gKiAkcmVmIGZpZWxkIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBPcGVuQVBJIGxpbmtcbiAqIChlLmcuIGFub3RoZXIvZGlyL2ZpbGUueWFtbCMvY29tcG9uZW50cy9zY2hlbWFzL0V4YW1wbGUpXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcGFyYW0geyp9IGN0eFxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlTm9kZShub2RlLCBjdHgpIHtcbiAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIHsgbm9kZSB9O1xuXG4gIGlmIChub2RlLiRyZWYpIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IGF3YWl0IHJlc29sdmUobm9kZS4kcmVmLCBjdHgpO1xuICAgIGlmIChyZXNvbHZlZC5ub2RlID09PSB1bmRlZmluZWQpIHsgLy8gY2FuJ3QgcmVzb2x2ZVxuICAgICAgcG9wUGF0aChjdHgpO1xuXG4gICAgICBjdHgucGF0aC5wdXNoKCckcmVmJyk7XG4gICAgICBjb25zdCBlcnJvciA9IHJlc29sdmVkLnRyYW5zaXRpdmVFcnJvclxuICAgICAgICA/IHJlc29sdmVkLnRyYW5zaXRpdmVFcnJvclxuICAgICAgICA6IGNyZWF0ZUVycm9yKCdSZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuJywgbm9kZSwgY3R4LCB7IGZyb21SdWxlOiAncmVzb2x2ZS1yZWYnIH0pO1xuICAgICAgY3R4LnBhdGgucG9wKCk7XG5cbiAgICAgIGN0eC5yZXN1bHQucHVzaChlcnJvcik7XG5cbiAgICAgIHJldHVybiB7IG5vZGUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBub2RlOiByZXNvbHZlZC5ub2RlLCBvblN0YWNrOiB0cnVlIH07XG4gIH1cblxuICByZXR1cm4geyBub2RlIH07XG59XG5cbi8vIHRvIGJlIHVzZWQgaW4gbXV0YXRvcnNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlTm9kZU5vU2lkZUVmZmVjdHMobm9kZSwgY3R4KSB7XG4gIGNvbnN0IGN0eENvcHkgPSB7IC4uLmN0eCwgcGF0aFN0YWNrOiBjdHgucGF0aFN0YWNrLnNsaWNlKCkgfTtcbiAgcmV0dXJuIHJlc29sdmVOb2RlKG5vZGUsIGN0eENvcHkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCByZXNvbHZlTm9kZTtcbiJdfQ==