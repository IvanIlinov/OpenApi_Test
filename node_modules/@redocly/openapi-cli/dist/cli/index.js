#!/usr/bin/env node
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _commander = _interopRequireDefault(require("commander"));

var _fs = _interopRequireDefault(require("fs"));

var _path = require("path");

var chockidar = _interopRequireWildcard(require("chokidar"));

var _redocly = _interopRequireDefault(require("../redocly"));

var _utils = require("./utils");

var _validate = require("../validate");

var _bundle = require("../bundle");

var _utils2 = require("../utils");

var _outputMessages = require("./outputMessages");

var _config = require("../config");

var _previewDocs = _interopRequireDefault(require("../preview-docs"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const program = new _commander.default.Command();

const validateFile = async (filePath, options, cmdObj) => {
  let result;

  if (!_fs.default.existsSync(filePath) && (0, _utils2.isFullyQualifiedUrl)(filePath)) {
    process.stdout.write('Will validate from URL\n');
    result = await (0, _validate.validateFromUrl)(filePath, options);
  } else {
    result = await (0, _validate.validateFromFile)(filePath, options);
  }

  const resultStats = (0, _outputMessages.outputMessages)(result, cmdObj);
  const {
    totalErrors,
    totalWarnings
  } = resultStats;
  process.stdout.write(`${_chalk.default.blueBright(filePath)} results. Errors: ${totalErrors}, warnings: ${totalWarnings}\n`);
  return {
    errors: resultStats.totalErrors,
    warnings: resultStats.totalWarnings
  };
};

const cli = () => {
  const f = _fs.default.readFileSync(`${__dirname}/../package.json`, 'utf-8');

  const {
    version
  } = JSON.parse(f);
  program.version(version, '-v, --version', 'Output current version of the OpenAPI CLI.');
  program.command('registry:login').description('Login to the Redoc.ly API Registry with access token').option('-p, --prompt', 'Ask for credentials instead of looking them in the .env or enviroment variables').action(async () => {
    const clientToken = await (0, _utils.promptUser)(_chalk.default.green(`\n  ðŸ”‘ Copy your access token from ${_chalk.default.blue(`https://app.${process.env.REDOCLY_DOMAIN || 'redoc.ly'}/profile`)} and paste it below`));
    const client = new _redocly.default();
    client.login(clientToken);
  });
  program.command('registry:logout').description('Clear stored credentials for Redoc.ly API Registry').action(async () => {
    const client = new _redocly.default();
    client.logout();
  });
  program.command('bundle [entryPoints...]').description('Create a bundle using <entryPoint> as a root document.').option('-o, --output <outputName>', 'Filename or folder for the bundle.').option('--short', 'Reduce output in case of bundling errors.').option('--ext <ext>', 'Output extension: json, yaml or yml').option('-f, --force', 'Produce bundle output file even if validation errors were encountered').action(async (entryPoints, cmdObj) => {
    if (cmdObj.ext && ['yaml', 'yml', 'json'].indexOf(cmdObj.ext) === -1) {
      process.stdout.write('Unsupported value for --ext option. Supported values are: yaml, yml or json');
      process.exit(1);
    }

    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    const isOutputDir = cmdObj.output && !(0, _path.extname)(cmdObj.output);
    const ext = cmdObj.ext || (0, _path.extname)(cmdObj.output || '').substring(1) || 'yaml';
    const dir = isOutputDir ? cmdObj.output : (0, _path.dirname)(cmdObj.output || '');
    const results = {
      errors: 0,
      warnings: 0
    };

    for (const entryPoint of entryPoints) {
      let output;

      if (cmdObj.output) {
        const fileName = isOutputDir ? (0, _path.basename)(entryPoint, (0, _path.extname)(entryPoint)) : (0, _path.basename)(cmdObj.output, `.${ext}`);
        output = (0, _path.join)(dir, `${fileName}.${ext}`);
      }

      const bundlingStatus = await (0, _bundle.bundleToFile)(entryPoint, output, cmdObj.force);
      const resultStats = (0, _outputMessages.outputMessages)(bundlingStatus, cmdObj);

      if (resultStats.totalErrors === 0) {
        // we do not want to output anything to stdout if it's being piped.
        if (output) {
          process.stdout.write(`Created a bundle for ${entryPoint} at ${output}\n`);
        }
      } else {
        if (cmdObj.force) {
          process.stderr.write(`Created a bundle for ${entryPoint} at ${output}. Errors ignored because of --force\n`);
        } else {
          process.stderr.write(`Errors encountered while bundling ${entryPoint}: bundle not created (use --force to ignore errors)\n`);
        }

        results.errors += resultStats.totalErrors;
        results.warnings += resultStats.totalWarnings;
      }
    }

    process.exit(results.errors === 0 || cmdObj.force ? 0 : 1);
  });
  program.command('validate [entryPoints...]').description('Validate given OpenAPI 3 definition file.').option('--short', 'Reduce output to required minimun.').option('--no-frame', 'Print no codeframes with errors.').option('--config <path>', 'Specify custom yaml or json config').action(async (entryPoints, cmdObj) => {
    const options = {};
    const results = {
      errors: 0,
      warnings: 0
    };
    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    options.codeframes = cmdObj.frame;
    if (cmdObj.config) options.configPath = cmdObj.config;

    for (let i = 0; i < entryPoints.length; i++) {
      (0, _outputMessages.printValidationHeader)(entryPoints[i]);
      const msgs = await validateFile(entryPoints[i], options, cmdObj);
      results.errors += msgs.errors;
      results.warnings += msgs.warnings;
    }

    if (entryPoints.length > 1) {
      process.stdout.write(`Total results. Errors: ${results.errors}, warnings: ${results.warnings}\n`);
    }

    process.exit(results.errors > 0 ? 1 : 0);
  });

  function myParseInt(value) {
    return parseInt(value, 10);
  }

  program.command('preview-docs [entryPoint]').description('Preview API Reference docs for the specified entrypoint OAS definition').option('-p, --port <value>', 'Preview port', myParseInt, 8080).action(async (entryPoint, cmdObj) => {
    const output = 'dist/openapi.yaml';
    let config = (0, _config.getConfig)({});

    if (!entryPoint) {
      // eslint-disable-next-line no-param-reassign, prefer-destructuring
      entryPoint = (0, _config.getFallbackEntryPointsOrExit)([], config)[0];
    }

    let cachedBundle;
    const deps = new Set();

    async function getBundle() {
      return cachedBundle;
    }

    async function updateBundle() {
      process.stdout.write('\nBundling...\n\n');
      const {
        bundle: openapiBundle,
        result,
        fileDependencies
      } = await (0, _bundle.bundle)(entryPoint, output, {
        lint: {
          codeframes: false
        }
      });
      const removed = [...deps].filter(x => !fileDependencies.has(x));
      watcher.unwatch(removed);
      watcher.add([...fileDependencies]);
      deps.clear();
      fileDependencies.forEach(deps.add, deps);
      const resultStats = (0, _outputMessages.outputMessages)(result, {
        short: true
      });

      if (resultStats.totalErrors === 0) {
        process.stdout.write(resultStats.totalErrors === 0 ? `Created a bundle for ${entryPoint} ${resultStats.totalWarnings > 0 ? 'with warnings' : 'successfully'}\n` : _chalk.default.yellow(`Created a bundle for ${entryPoint} with errors. Docs may be broken or not accurate\n`));
      }

      return openapiBundle;
    }

    setImmediate(() => {
      cachedBundle = updateBundle();
    }); // initial cache

    const hotClients = await (0, _previewDocs.default)(cmdObj.port, {
      getBundle,
      getOptions: () => config.referenceDocs
    });
    const watcher = chockidar.watch([entryPoint, config.configPath], {
      disableGlobbing: true,
      ignoreInitial: true
    });
    const debouncedUpdatedeBundle = (0, _utils2.debounce)(async () => {
      cachedBundle = updateBundle();
      await cachedBundle;
      hotClients.broadcast('{"type": "reload", "bundle": true}');
    }, 2000);

    const changeHandler = async (type, file) => {
      process.stdout.write(`${_chalk.default.green('watch')} ${type} ${_chalk.default.blue(file)}\n`);

      if (file === config.configPath) {
        config = (0, _config.getConfig)({
          configPath: file
        });
        hotClients.broadcast(JSON.stringify({
          type: 'reload'
        }));
        return;
      }

      debouncedUpdatedeBundle();
    };

    watcher.on('change', changeHandler.bind(undefined, 'changed'));
    watcher.on('add', changeHandler.bind(undefined, 'added'));
    watcher.on('unlink', changeHandler.bind(undefined, 'removed'));
    watcher.on('ready', () => {
      process.stdout.write(`\n  ðŸ‘€  Watching ${_chalk.default.blue(entryPoint)} and all related resources for changes\n`);
    });
  });
  program.on('command:*', () => {
    process.stderr.write(`\nUnknown command ${program.args.join(' ')}\n\n`);
    program.outputHelp();
  });
  if (process.argv.length === 2) process.argv.push('-h');
  program.parse(process.argv);
};

var _default = cli;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvaW5kZXguanMiXSwibmFtZXMiOlsicHJvZ3JhbSIsImNvbW1hbmRlciIsIkNvbW1hbmQiLCJ2YWxpZGF0ZUZpbGUiLCJmaWxlUGF0aCIsIm9wdGlvbnMiLCJjbWRPYmoiLCJyZXN1bHQiLCJmcyIsImV4aXN0c1N5bmMiLCJwcm9jZXNzIiwic3Rkb3V0Iiwid3JpdGUiLCJyZXN1bHRTdGF0cyIsInRvdGFsRXJyb3JzIiwidG90YWxXYXJuaW5ncyIsImNoYWxrIiwiYmx1ZUJyaWdodCIsImVycm9ycyIsIndhcm5pbmdzIiwiY2xpIiwiZiIsInJlYWRGaWxlU3luYyIsIl9fZGlybmFtZSIsInZlcnNpb24iLCJKU09OIiwicGFyc2UiLCJjb21tYW5kIiwiZGVzY3JpcHRpb24iLCJvcHRpb24iLCJhY3Rpb24iLCJjbGllbnRUb2tlbiIsImdyZWVuIiwiYmx1ZSIsImVudiIsIlJFRE9DTFlfRE9NQUlOIiwiY2xpZW50IiwiUmVkb2NseUNsaWVudCIsImxvZ2luIiwibG9nb3V0IiwiZW50cnlQb2ludHMiLCJleHQiLCJpbmRleE9mIiwiZXhpdCIsImNvbmZpZyIsImlzT3V0cHV0RGlyIiwib3V0cHV0Iiwic3Vic3RyaW5nIiwiZGlyIiwicmVzdWx0cyIsImVudHJ5UG9pbnQiLCJmaWxlTmFtZSIsImJ1bmRsaW5nU3RhdHVzIiwiZm9yY2UiLCJzdGRlcnIiLCJjb2RlZnJhbWVzIiwiZnJhbWUiLCJjb25maWdQYXRoIiwiaSIsImxlbmd0aCIsIm1zZ3MiLCJteVBhcnNlSW50IiwidmFsdWUiLCJwYXJzZUludCIsImNhY2hlZEJ1bmRsZSIsImRlcHMiLCJTZXQiLCJnZXRCdW5kbGUiLCJ1cGRhdGVCdW5kbGUiLCJidW5kbGUiLCJvcGVuYXBpQnVuZGxlIiwiZmlsZURlcGVuZGVuY2llcyIsImxpbnQiLCJyZW1vdmVkIiwiZmlsdGVyIiwieCIsImhhcyIsIndhdGNoZXIiLCJ1bndhdGNoIiwiYWRkIiwiY2xlYXIiLCJmb3JFYWNoIiwic2hvcnQiLCJ5ZWxsb3ciLCJzZXRJbW1lZGlhdGUiLCJob3RDbGllbnRzIiwicG9ydCIsImdldE9wdGlvbnMiLCJyZWZlcmVuY2VEb2NzIiwiY2hvY2tpZGFyIiwid2F0Y2giLCJkaXNhYmxlR2xvYmJpbmciLCJpZ25vcmVJbml0aWFsIiwiZGVib3VuY2VkVXBkYXRlZGVCdW5kbGUiLCJicm9hZGNhc3QiLCJjaGFuZ2VIYW5kbGVyIiwidHlwZSIsImZpbGUiLCJzdHJpbmdpZnkiLCJvbiIsImJpbmQiLCJ1bmRlZmluZWQiLCJhcmdzIiwiam9pbiIsIm91dHB1dEhlbHAiLCJhcmd2IiwicHVzaCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBR0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBRUEsTUFBTUEsT0FBTyxHQUFHLElBQUlDLG1CQUFVQyxPQUFkLEVBQWhCOztBQUVBLE1BQU1DLFlBQVksR0FBRyxPQUFPQyxRQUFQLEVBQWlCQyxPQUFqQixFQUEwQkMsTUFBMUIsS0FBcUM7QUFDeEQsTUFBSUMsTUFBSjs7QUFFQSxNQUFJLENBQUNDLFlBQUdDLFVBQUgsQ0FBY0wsUUFBZCxDQUFELElBQTRCLGlDQUFvQkEsUUFBcEIsQ0FBaEMsRUFBK0Q7QUFDN0RNLElBQUFBLE9BQU8sQ0FBQ0MsTUFBUixDQUFlQyxLQUFmLENBQXFCLDBCQUFyQjtBQUNBTCxJQUFBQSxNQUFNLEdBQUcsTUFBTSwrQkFBZ0JILFFBQWhCLEVBQTBCQyxPQUExQixDQUFmO0FBQ0QsR0FIRCxNQUdPO0FBQ0xFLElBQUFBLE1BQU0sR0FBRyxNQUFNLGdDQUFpQkgsUUFBakIsRUFBMkJDLE9BQTNCLENBQWY7QUFDRDs7QUFDRCxRQUFNUSxXQUFXLEdBQUcsb0NBQWVOLE1BQWYsRUFBdUJELE1BQXZCLENBQXBCO0FBRUEsUUFBTTtBQUFFUSxJQUFBQSxXQUFGO0FBQWVDLElBQUFBO0FBQWYsTUFBaUNGLFdBQXZDO0FBQ0FILEVBQUFBLE9B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a0IsR0FBbEIsQ0FBdUIsTUFBakU7QUFDQXZHLElBQUFBLE9BQU8sQ0FBQ3dHLFVBQVI7QUFDRCxHQUhEO0FBS0EsTUFBSTlGLE9BQU8sQ0FBQytGLElBQVIsQ0FBYTlDLE1BQWIsS0FBd0IsQ0FBNUIsRUFBK0JqRCxPQUFPLENBQUMrRixJQUFSLENBQWFDLElBQWIsQ0FBa0IsSUFBbEI7QUFFL0IxRyxFQUFBQSxPQUFPLENBQUMwQixLQUFSLENBQWNoQixPQUFPLENBQUMrRixJQUF0QjtBQUNELENBN05EOztlQStOZXJGLEciLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG5cbmltcG9ydCBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgY29tbWFuZGVyIGZyb20gJ2NvbW1hbmRlcic7XG5cbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQge1xuICBqb2luLCBiYXNlbmFtZSwgZGlybmFtZSwgZXh0bmFtZSxcbn0gZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjaG9ja2lkYXIgZnJvbSAnY2hva2lkYXInO1xuXG5pbXBvcnQgUmVkb2NseUNsaWVudCBmcm9tICcuLi9yZWRvY2x5JztcbmltcG9ydCB7IHByb21wdFVzZXIgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IHZhbGlkYXRlRnJvbUZpbGUsIHZhbGlkYXRlRnJvbVVybCB9IGZyb20gJy4uL3ZhbGlkYXRlJztcbmltcG9ydCB7IGJ1bmRsZSwgYnVuZGxlVG9GaWxlIH0gZnJvbSAnLi4vYnVuZGxlJztcblxuaW1wb3J0IHsgaXNGdWxseVF1YWxpZmllZFVybCwgZGVib3VuY2UgfSBmcm9tICcuLi91dGlscyc7XG5cbmltcG9ydCB7IG91dHB1dE1lc3NhZ2VzLCBwcmludFZhbGlkYXRpb25IZWFkZXIgfSBmcm9tICcuL291dHB1dE1lc3NhZ2VzJztcbmltcG9ydCB7IGdldEZhbGxiYWNrRW50cnlQb2ludHNPckV4aXQsIGdldENvbmZpZyB9IGZyb20gJy4uL2NvbmZpZyc7XG5cbmltcG9ydCBzdGFydFByZXZpZXdTZXJ2ZXIgZnJvbSAnLi4vcHJldmlldy1kb2NzJztcblxuY29uc3QgcHJvZ3JhbSA9IG5ldyBjb21tYW5kZXIuQ29tbWFuZCgpO1xuXG5jb25zdCB2YWxpZGF0ZUZpbGUgPSBhc3luYyAoZmlsZVBhdGgsIG9wdGlvbnMsIGNtZE9iaikgPT4ge1xuICBsZXQgcmVzdWx0O1xuXG4gIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkgJiYgaXNGdWxseVF1YWxpZmllZFVybChmaWxlUGF0aCkpIHtcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnV2lsbCB2YWxpZGF0ZSBmcm9tIFVSTFxcbicpO1xuICAgIHJlc3VsdCA9IGF3YWl0IHZhbGlkYXRlRnJvbVVybChmaWxlUGF0aCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgdmFsaWRhdGVGcm9tRmlsZShmaWxlUGF0aCwgb3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgcmVzdWx0U3RhdHMgPSBvdXRwdXRNZXNzYWdlcyhyZXN1bHQsIGNtZE9iaik7XG5cbiAgY29uc3QgeyB0b3RhbEVycm9ycywgdG90YWxXYXJuaW5ncyB9ID0gcmVzdWx0U3RhdHM7XG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKFxuICAgIGAke2NoYWxrLmJsdWVCcmlnaHQoZmlsZVBhdGgpfSByZXN1bHRzLiBFcnJvcnM6ICR7dG90YWxFcnJvcnN9LCB3YXJuaW5nczogJHt0b3RhbFdhcm5pbmdzfVxcbmAsXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBlcnJvcnM6IHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzLFxuICAgIHdhcm5pbmdzOiByZXN1bHRTdGF0cy50b3RhbFdhcm5pbmdzLFxuICB9O1xufTtcblxuY29uc3QgY2xpID0gKCkgPT4ge1xuICBjb25zdCBmID0gZnMucmVhZEZpbGVTeW5jKGAke19fZGlybmFtZX0vLi4vcGFja2FnZS5qc29uYCwgJ3V0Zi04Jyk7XG4gIGNvbnN0IHsgdmVyc2lvbiB9ID0gSlNPTi5wYXJzZShmKTtcblxuICBwcm9ncmFtXG4gICAgLnZlcnNpb24odmVyc2lvbiwgJy12LCAtLXZlcnNpb24nLCAnT3V0cHV0IGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBDTEkuJyk7XG5cbiAgcHJvZ3JhbVxuICAgIC5jb21tYW5kKCdyZWdpc3RyeTpsb2dpbicpXG4gICAgLmRlc2NyaXB0aW9uKCdMb2dpbiB0byB0aGUgUmVkb2MubHkgQVBJIFJlZ2lzdHJ5IHdpdGggYWNjZXNzIHRva2VuJylcbiAgICAub3B0aW9uKCctcCwgLS1wcm9tcHQnLCAnQXNrIGZvciBjcmVkZW50aWFscyBpbnN0ZWFkIG9mIGxvb2tpbmcgdGhlbSBpbiB0aGUgLmVudiBvciBlbnZpcm9tZW50IHZhcmlhYmxlcycpXG4gICAgLmFjdGlvbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjbGllbnRUb2tlbiA9IGF3YWl0IHByb21wdFVzZXIoXG4gICAgICAgIGNoYWxrLmdyZWVuKGBcXG4gIPCflJEgQ29weSB5b3VyIGFjY2VzcyB0b2tlbiBmcm9tICR7Y2hhbGsuYmx1ZShgaHR0cHM6Ly9hcHAuJHtwcm9jZXNzLmVudi5SRURPQ0xZX0RPTUFJTiB8fCAncmVkb2MubHknfS9wcm9maWxlYCl9IGFuZCBwYXN0ZSBpdCBiZWxvd2ApLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWRvY2x5Q2xpZW50KCk7XG4gICAgICBjbGllbnQubG9naW4oY2xpZW50VG9rZW4pO1xuICAgIH0pO1xuXG4gIHByb2dyYW1cbiAgICAuY29tbWFuZCgncmVnaXN0cnk6bG9nb3V0JylcbiAgICAuZGVzY3JpcHRpb24oJ0NsZWFyIHN0b3JlZCBjcmVkZW50aWFscyBmb3IgUmVkb2MubHkgQVBJIFJlZ2lzdHJ5JylcbiAgICAuYWN0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWRvY2x5Q2xpZW50KCk7XG4gICAgICBjbGllbnQubG9nb3V0KCk7XG4gICAgfSk7XG5cbiAgcHJvZ3JhbVxuICAgIC5jb21tYW5kKCdidW5kbGUgW2VudHJ5UG9pbnRzLi4uXScpXG4gICAgLmRlc2NyaXB0aW9uKCdDcmVhdGUgYSBidW5kbGUgdXNpbmcgPGVudHJ5UG9pbnQ+IGFzIGEgcm9vdCBkb2N1bWVudC4nKVxuICAgIC5vcHRpb24oJy1vLCAtLW91dHB1dCA8b3V0cHV0TmFtZT4nLCAnRmlsZW5hbWUgb3IgZm9sZGVyIGZvciB0aGUgYnVuZGxlLicpXG4gICAgLm9wdGlvbignLS1zaG9ydCcsICdSZWR1Y2Ugb3V0cHV0IGluIGNhc2Ugb2YgYnVuZGxpbmcgZXJyb3JzLicpXG4gICAgLm9wdGlvbignLS1leHQgPGV4dD4nLCAnT3V0cHV0IGV4dGVuc2lvbjoganNvbiwgeWFtbCBvciB5bWwnKVxuICAgIC5vcHRpb24oJy1mLCAtLWZvcmNlJywgJ1Byb2R1Y2UgYnVuZGxlIG91dHB1dCBmaWxlIGV2ZW4gaWYgdmFsaWRhdGlvbiBlcnJvcnMgd2VyZSBlbmNvdW50ZXJlZCcpXG4gICAgLmFjdGlvbihhc3luYyAoZW50cnlQb2ludHMsIGNtZE9iaikgPT4ge1xuICAgICAgaWYgKGNtZE9iai5leHQgJiYgWyd5YW1sJywgJ3ltbCcsICdqc29uJ10uaW5kZXhPZihjbWRPYmouZXh0KSA9PT0gLTEpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIHZhbHVlIGZvciAtLWV4dCBvcHRpb24uIFN1cHBvcnRlZCB2YWx1ZXMgYXJlOiB5YW1sLCB5bWwgb3IganNvbicsXG4gICAgICAgICk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKHt9KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZW50cnlQb2ludHMgPSBnZXRGYWxsYmFja0VudHJ5UG9pbnRzT3JFeGl0KGVudHJ5UG9pbnRzLCBjb25maWcpO1xuXG4gICAgICBjb25zdCBpc091dHB1dERpciA9IGNtZE9iai5vdXRwdXQgJiYgIWV4dG5hbWUoY21kT2JqLm91dHB1dCk7XG4gICAgICBjb25zdCBleHQgPSBjbWRPYmouZXh0IHx8IGV4dG5hbWUoY21kT2JqLm91dHB1dCB8fCAnJykuc3Vic3RyaW5nKDEpIHx8ICd5YW1sJztcbiAgICAgIGNvbnN0IGRpciA9IGlzT3V0cHV0RGlyID8gY21kT2JqLm91dHB1dCA6IGRpcm5hbWUoY21kT2JqLm91dHB1dCB8fCAnJyk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7XG4gICAgICAgIGVycm9yczogMCxcbiAgICAgICAgd2FybmluZ3M6IDAsXG4gICAgICB9O1xuXG4gICAgICBmb3IgKGNvbnN0IGVudHJ5UG9pbnQgb2YgZW50cnlQb2ludHMpIHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgaWYgKGNtZE9iai5vdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGlzT3V0cHV0RGlyXG4gICAgICAgICAgICA/IGJhc2VuYW1lKGVudHJ5UG9pbnQsIGV4dG5hbWUoZW50cnlQb2ludCkpXG4gICAgICAgICAgICA6IGJhc2VuYW1lKGNtZE9iai5vdXRwdXQsIGAuJHtleHR9YCk7XG4gICAgICAgICAgb3V0cHV0ID0gam9pbihkaXIsIGAke2ZpbGVOYW1lfS4ke2V4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1bmRsaW5nU3RhdHVzID0gYXdhaXQgYnVuZGxlVG9GaWxlKGVudHJ5UG9pbnQsIG91dHB1dCwgY21kT2JqLmZvcmNlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0U3RhdHMgPSBvdXRwdXRNZXNzYWdlcyhidW5kbGluZ1N0YXR1cywgY21kT2JqKTtcblxuICAgICAgICBpZiAocmVzdWx0U3RhdHMudG90YWxFcnJvcnMgPT09IDApIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBvdXRwdXQgYW55dGhpbmcgdG8gc3Rkb3V0IGlmIGl0J3MgYmVpbmcgcGlwZWQuXG4gICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYENyZWF0ZWQgYSBidW5kbGUgZm9yICR7ZW50cnlQb2ludH0gYXQgJHtvdXRwdXR9XFxuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjbWRPYmouZm9yY2UpIHtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKFxuICAgICAgICAgICAgICBgQ3JlYXRlZCBhIGJ1bmRsZSBmb3IgJHtlbnRyeVBvaW50fSBhdCAke291dHB1dH0uIEVycm9ycyBpZ25vcmVkIGJlY2F1c2Ugb2YgLS1mb3JjZVxcbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcbiAgICAgICAgICAgICAgYEVycm9ycyBlbmNvdW50ZXJlZCB3aGlsZSBidW5kbGluZyAke2VudHJ5UG9pbnR9OiBidW5kbGUgbm90IGNyZWF0ZWQgKHVzZSAtLWZvcmNlIHRvIGlnbm9yZSBlcnJvcnMpXFxuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMuZXJyb3JzICs9IHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzO1xuICAgICAgICAgIHJlc3VsdHMud2FybmluZ3MgKz0gcmVzdWx0U3RhdHMudG90YWxXYXJuaW5ncztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvY2Vzcy5leGl0KHJlc3VsdHMuZXJyb3JzID09PSAwIHx8IGNtZE9iai5mb3JjZSA/IDAgOiAxKTtcbiAgICB9KTtcblxuICBwcm9ncmFtXG4gICAgLmNvbW1hbmQoJ3ZhbGlkYXRlIFtlbnRyeVBvaW50cy4uLl0nKVxuICAgIC5kZXNjcmlwdGlvbignVmFsaWRhdGUgZ2l2ZW4gT3BlbkFQSSAzIGRlZmluaXRpb24gZmlsZS4nKVxuICAgIC5vcHRpb24oJy0tc2hvcnQnLCAnUmVkdWNlIG91dHB1dCB0byByZXF1aXJlZCBtaW5pbXVuLicpXG4gICAgLm9wdGlvbignLS1uby1mcmFtZScsICdQcmludCBubyBjb2RlZnJhbWVzIHdpdGggZXJyb3JzLicpXG4gICAgLm9wdGlvbignLS1jb25maWcgPHBhdGg+JywgJ1NwZWNpZnkgY3VzdG9tIHlhbWwgb3IganNvbiBjb25maWcnKVxuICAgIC5hY3Rpb24oYXN5bmMgKGVudHJ5UG9pbnRzLCBjbWRPYmopID0+IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7XG4gICAgICAgIGVycm9yczogMCxcbiAgICAgICAgd2FybmluZ3M6IDAsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBjb25maWcgPSBnZXRDb25maWcoe30pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBlbnRyeVBvaW50cyA9IGdldEZhbGxiYWNrRW50cnlQb2ludHNPckV4aXQoZW50cnlQb2ludHMsIGNvbmZpZyk7XG5cbiAgICAgIG9wdGlvbnMuY29kZWZyYW1lcyA9IGNtZE9iai5mcmFtZTtcbiAgICAgIGlmIChjbWRPYmouY29uZmlnKSBvcHRpb25zLmNvbmZpZ1BhdGggPSBjbWRPYmouY29uZmlnO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJ5UG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByaW50VmFsaWRhdGlvbkhlYWRlcihlbnRyeVBvaW50c1tpXSk7XG5cbiAgICAgICAgY29uc3QgbXNncyA9IGF3YWl0IHZhbGlkYXRlRmlsZShlbnRyeVBvaW50c1tpXSwgb3B0aW9ucywgY21kT2JqKTtcbiAgICAgICAgcmVzdWx0cy5lcnJvcnMgKz0gbXNncy5lcnJvcnM7XG4gICAgICAgIHJlc3VsdHMud2FybmluZ3MgKz0gbXNncy53YXJuaW5ncztcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeVBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGBUb3RhbCByZXN1bHRzLiBFcnJvcnM6ICR7cmVzdWx0cy5lcnJvcnN9LCB3YXJuaW5nczogJHtyZXN1bHRzLndhcm5pbmdzfVxcbmApO1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5leGl0KHJlc3VsdHMuZXJyb3JzID4gMCA/IDEgOiAwKTtcbiAgICB9KTtcblxuICBmdW5jdGlvbiBteVBhcnNlSW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gIH1cblxuICBwcm9ncmFtXG4gICAgLmNvbW1hbmQoJ3ByZXZpZXctZG9jcyBbZW50cnlQb2ludF0nKVxuICAgIC5kZXNjcmlwdGlvbignUHJldmlldyBBUEkgUmVmZXJlbmNlIGRvY3MgZm9yIHRoZSBzcGVjaWZpZWQgZW50cnlwb2ludCBPQVMgZGVmaW5pdGlvbicpXG4gICAgLm9wdGlvbignLXAsIC0tcG9ydCA8dmFsdWU+JywgJ1ByZXZpZXcgcG9ydCcsIG15UGFyc2VJbnQsIDgwODApXG4gICAgLmFjdGlvbihhc3luYyAoZW50cnlQb2ludCwgY21kT2JqKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXQgPSAnZGlzdC9vcGVuYXBpLnlhbWwnO1xuXG4gICAgICBsZXQgY29uZmlnID0gZ2V0Q29uZmlnKHt9KTtcbiAgICAgIGlmICghZW50cnlQb2ludCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ24sIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIGVudHJ5UG9pbnQgPSBnZXRGYWxsYmFja0VudHJ5UG9pbnRzT3JFeGl0KFtdLCBjb25maWcpWzBdO1xuICAgICAgfVxuXG4gICAgICBsZXQgY2FjaGVkQnVuZGxlO1xuICAgICAgY29uc3QgZGVwcyA9IG5ldyBTZXQoKTtcblxuICAgICAgYXN5bmMgZnVuY3Rpb24gZ2V0QnVuZGxlKCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkQnVuZGxlO1xuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiB1cGRhdGVCdW5kbGUoKSB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG5CdW5kbGluZy4uLlxcblxcbicpO1xuICAgICAgICBjb25zdCB7IGJ1bmRsZTogb3BlbmFwaUJ1bmRsZSwgcmVzdWx0LCBmaWxlRGVwZW5kZW5jaWVzIH0gPSBhd2FpdCBidW5kbGUoZW50cnlQb2ludCwgb3V0cHV0LCB7XG4gICAgICAgICAgbGludDoge1xuICAgICAgICAgICAgY29kZWZyYW1lczogZmFsc2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IFsuLi5kZXBzXS5maWx0ZXIoKHgpID0+ICFmaWxlRGVwZW5kZW5jaWVzLmhhcyh4KSk7XG4gICAgICAgIHdhdGNoZXIudW53YXRjaChyZW1vdmVkKTtcbiAgICAgICAgd2F0Y2hlci5hZGQoWy4uLmZpbGVEZXBlbmRlbmNpZXNdKTtcbiAgICAgICAgZGVwcy5jbGVhcigpO1xuICAgICAgICBmaWxlRGVwZW5kZW5jaWVzLmZvckVhY2goZGVwcy5hZGQsIGRlcHMpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdFN0YXRzID0gb3V0cHV0TWVzc2FnZXMocmVzdWx0LCB7IHNob3J0OiB0cnVlIH0pO1xuXG4gICAgICAgIGlmIChyZXN1bHRTdGF0cy50b3RhbEVycm9ycyA9PT0gMCkge1xuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKFxuICAgICAgICAgICAgcmVzdWx0U3RhdHMudG90YWxFcnJvcnMgPT09IDBcbiAgICAgICAgICAgICAgPyBgQ3JlYXRlZCBhIGJ1bmRsZSBmb3IgJHtlbnRyeVBvaW50fSAke3Jlc3VsdFN0YXRzLnRvdGFsV2FybmluZ3MgPiAwID8gJ3dpdGggd2FybmluZ3MnIDogJ3N1Y2Nlc3NmdWxseSd9XFxuYFxuICAgICAgICAgICAgICA6IGNoYWxrLnllbGxvdyhgQ3JlYXRlZCBhIGJ1bmRsZSBmb3IgJHtlbnRyeVBvaW50fSB3aXRoIGVycm9ycy4gRG9jcyBtYXkgYmUgYnJva2VuIG9yIG5vdCBhY2N1cmF0ZVxcbmApLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3BlbmFwaUJ1bmRsZTtcbiAgICAgIH1cblxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgY2FjaGVkQnVuZGxlID0gdXBkYXRlQnVuZGxlKCk7XG4gICAgICB9KTsgLy8gaW5pdGlhbCBjYWNoZVxuXG4gICAgICBjb25zdCBob3RDbGllbnRzID0gYXdhaXQgc3RhcnRQcmV2aWV3U2VydmVyKGNtZE9iai5wb3J0LCB7XG4gICAgICAgIGdldEJ1bmRsZSxcbiAgICAgICAgZ2V0T3B0aW9uczogKCkgPT4gY29uZmlnLnJlZmVyZW5jZURvY3MsXG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgd2F0Y2hlciA9IGNob2NraWRhci53YXRjaChbZW50cnlQb2ludCwgY29uZmlnLmNvbmZpZ1BhdGhdLCB7XG4gICAgICAgIGRpc2FibGVHbG9iYmluZzogdHJ1ZSxcbiAgICAgICAgaWdub3JlSW5pdGlhbDogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkZWJvdW5jZWRVcGRhdGVkZUJ1bmRsZSA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgICAgICAgY2FjaGVkQnVuZGxlID0gdXBkYXRlQnVuZGxlKCk7XG4gICAgICAgIGF3YWl0IGNhY2hlZEJ1bmRsZTtcbiAgICAgICAgaG90Q2xpZW50cy5icm9hZGNhc3QoJ3tcInR5cGVcIjogXCJyZWxvYWRcIiwgXCJidW5kbGVcIjogdHJ1ZX0nKTtcbiAgICAgIH0sIDIwMDApO1xuXG4gICAgICBjb25zdCBjaGFuZ2VIYW5kbGVyID0gYXN5bmMgKHR5cGUsIGZpbGUpID0+IHtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7Y2hhbGsuZ3JlZW4oJ3dhdGNoJyl9ICR7dHlwZX0gJHtjaGFsay5ibHVlKGZpbGUpfVxcbmApO1xuICAgICAgICBpZiAoZmlsZSA9PT0gY29uZmlnLmNvbmZpZ1BhdGgpIHtcbiAgICAgICAgICBjb25maWcgPSBnZXRDb25maWcoeyBjb25maWdQYXRoOiBmaWxlIH0pO1xuICAgICAgICAgIGhvdENsaWVudHMuYnJvYWRjYXN0KEpTT04uc3RyaW5naWZ5KHsgdHlwZTogJ3JlbG9hZCcgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYm91bmNlZFVwZGF0ZWRlQnVuZGxlKCk7XG4gICAgICB9O1xuXG4gICAgICB3YXRjaGVyLm9uKCdjaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyLmJpbmQodW5kZWZpbmVkLCAnY2hhbmdlZCcpKTtcbiAgICAgIHdhdGNoZXIub24oJ2FkZCcsIGNoYW5nZUhhbmRsZXIuYmluZCh1bmRlZmluZWQsICdhZGRlZCcpKTtcbiAgICAgIHdhdGNoZXIub24oJ3VubGluaycsIGNoYW5nZUhhbmRsZXIuYmluZCh1bmRlZmluZWQsICdyZW1vdmVkJykpO1xuXG4gICAgICB3YXRjaGVyLm9uKCdyZWFkeScsICgpID0+IHtcbiAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxcbiAg8J+RgCAgV2F0Y2hpbmcgJHtjaGFsay5ibHVlKGVudHJ5UG9pbnQpfSBhbmQgYWxsIHJlbGF0ZWQgcmVzb3VyY2VzIGZvciBjaGFuZ2VzXFxuYCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICBwcm9ncmFtLm9uKCdjb21tYW5kOionLCAoKSA9PiB7XG4gICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoYFxcblVua25vd24gY29tbWFuZCAke3Byb2dyYW0uYXJncy5qb2luKCcgJyl9XFxuXFxuYCk7XG4gICAgcHJvZ3JhbS5vdXRwdXRIZWxwKCk7XG4gIH0pO1xuXG4gIGlmIChwcm9jZXNzLmFyZ3YubGVuZ3RoID09PSAyKSBwcm9jZXNzLmFyZ3YucHVzaCgnLWgnKTtcblxuICBwcm9ncmFtLnBhcnNlKHByb2Nlc3MuYXJndik7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGk7XG4iXX0=